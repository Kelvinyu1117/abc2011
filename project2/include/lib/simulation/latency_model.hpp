#pragma once

#include <cstdint>
namespace simulation {

/**
 * @brief Provide a way to simulate the latency of the feed, order entry,
 * order response, it is expected to alter the market data feed generated by the
 * HistMDContext, and the order generated by the ExecutionContext
 *
 */
template <typename DataTraits> class LatencyModel {
public:
  using NanoTimestamp = DataTraits::NanoTimestamp;

  virtual NanoTimestamp get_feed_latency() = 0;

  virtual NanoTimestamp get_order_entry_latency() = 0;

  virtual NanoTimestamp get_order_response_latency() = 0;

  virtual ~LatencyModel() {}
};

template <typename DataTraits>
struct NoLatencyModel final : public LatencyModel<DataTraits> {
  using NanoTimestamp = DataTraits::NanoTimestamp;

  NanoTimestamp get_feed_latency() override { return 0; }

  NanoTimestamp get_order_entry_latency() override { return 0; }

  NanoTimestamp get_order_response_latency() override { return 0; }
};

template <typename DataTraits>
struct ConstantLatencyModel final : public LatencyModel<DataTraits> {
  using NanoTimestamp = DataTraits::NanoTimestamp;

  ConstantLatencyModel(NanoTimestamp feed_latency,
                       NanoTimestamp order_entry_latency,
                       NanoTimestamp order_response_latency)
      : feed_latency{feed_latency}, order_entry_latency{order_entry_latency},
        order_response_latency{order_response_latency} {}

  NanoTimestamp get_feed_latency() override { return feed_latency; }

  NanoTimestamp get_order_entry_latency() override {
    return order_entry_latency;
  }

  NanoTimestamp get_order_response_latency() override {
    return order_response_latency;
  }

private:
  const NanoTimestamp feed_latency;
  const NanoTimestamp order_entry_latency;
  const NanoTimestamp order_response_latency;
};

} // namespace simulation
